/**
 * Auto-generated by build.js
 * Contains a simplified global declaration for WSocketClient.
 * All internal dependencies are replaced with 'any'.
 */

declare type WSocket = any;
declare type __global = any;
declare type WSocketProtoBuf = any;



/**
 * WebSocket 客户端错误码定义
 * 错误码范围说明：
 * - 100000-199999: 连接相关错误
 * - 200000-299999: 协议处理相关错误
 */
declare const WSMessage: {
    /******************** 连接相关错误 (100000-199999) ********************/
    /**
     * 请先调用 setConfig 方法
     * 错误码: 100000
     * 触发场景: 在调用 connect() 方法之前未调用 setConfig() 设置协议配置
     * 解决方法: 确保在连接前先调用 client.setConfig(proto_config)
     */
    CALL_ERROR: 100000;

    /**
     * 当前正在连接 WebSocket，请勿重复连接
     * 错误码: 100001
     * 触发场景: 在连接状态为 CONNECTING 时，再次调用 connect() 方法
     * 解决方法: 等待当前连接完成后再尝试连接
     */
    CONNECTING_REPEAT_ERROR: 100001;

    /**
     * 连接超时
     * 错误码: 100002
     * 触发场景: 从开始连接到连接成功或失败的时间超过了 config.connectTimeout 设置的值
     * 解决方法: 检查网络连接，或增加 connectTimeout 的值
     */
    CONNECT_TIMEOUT: 100002;

    /**
     * 协议超时
     * 错误码: 100003
     * 触发场景: 发送请求后，在 config.protocolTimeout 时间内未收到服务器响应
     * 解决方法: 检查服务器是否正常响应，或增加 protocolTimeout 的值
     */
    PROTOCOL_TIMEOUT: 100003;

    /**
     * 心跳超时
     * 错误码: 100004
     * 触发场景: 发送心跳包后，在 config.heartbeatTimeout 时间内未收到心跳响应
     * 解决方法: 检查网络连接，服务器可能会主动断开连接
     */
    HEARTBEAT_TIMEOUT: 100004;

    /**
     * 心跳响应失败
     * 错误码: 100005
     * 触发场景: 收到心跳响应，但响应状态码不为 0（表示心跳失败）
     * 解决方法: 检查服务器心跳处理逻辑
     */
    HEARTBEAT_FAILED: 100005;
    /**
     *  当前正在连接，请等待连接完成
     * 错误码: 100006
     * 触发场景: 在连接状态为 CONNECTING 时，再次调用 send 方法
     * 解决方法: 等待当前连接完成后再尝试发送消息
     */
    CONNECTING_NOW: 100006;

    /******************** 协议处理相关错误 (200000-299999) ********************/

    /**
     * Protobuf 解析错误
     * 错误码: 200000
     * 触发场景: 在 setConfig() 时，protobuf 定义文件解析失败，无法找到对应的 package
     * 解决方法: 检查 proto_define 配置是否正确，确保 package 名称匹配
     */
    PROTO_PARSE_ERROR: 200000;

    /**
     * CSV 配置错误，cmdMerge 无法找到对应的配置
     * 错误码: 200001
     * 触发场景: 收到服务器消息时，根据 cmdMerge 无法在 proto_configs 中找到对应的协议配置
     * 解决方法: 检查 ProtoConfig.csv 配置，确保 cmdMerge 值已正确配置
     */
    CSV_ERROR: 200001;

    /**
     * CSV 配置错误，响应消息名称为空
     * 错误码: 200002
     * 触发场景: 收到服务器消息时，协议配置中缺少响应消息名称（response 字段为空）
     * 解决方法: 检查 ProtoConfig.csv 配置，确保每个 cmdMerge 都配置了对应的 response 消息名称
     */
    CSV_NO_RESPONSE: 200002;

    /**
     * 找不到 cmdMerge 配置
     * 错误码: 200003
     * 触发场景: 发送消息时，根据消息名称（msgName）无法在 proto_configs 中找到对应的 cmdMerge
     * 解决方法: 检查 ProtoConfig.csv 配置，确保该消息名称已正确配置 cmdMerge
     */
    CMDMERGE_NOT_FOUND: 200003;

    /**
     * 找不到 ExternalMessage 定义
     * 错误码: 200004
     * 触发场景: 编码消息时，在 protobuf 定义中找不到 ExternalMessage 类型
     * 解决方法: 检查 .proto 文件，确保定义了 ExternalMessage 消息类型
     */
    MESSAGE_NOT_FOUND: 200004;

    /**
     * 没有处理函数和监听器，这表明该数据可以被客户端忽略
     * 错误码: 200005
     * 触发场景: 没有处理函数和监听器，这表明该数据可以被客户端忽略
     * 解决方法: 检查处理函数和监听器是否正确
     */
    NO_HANDLER: 200005;

    /**
     * 编码消息失败
     * 错误码: 200010
     * 触发场景: 将消息对象编码为 Protobuf 二进制数据时失败
     * 解决方法: 检查消息对象格式是否正确，是否符合 protobuf 定义
     */
    ENCODE_FAILED: 200010;

    /**
     * 解码消息失败
     * 错误码: 200011
     * 触发场景: 将 Protobuf 二进制数据解码为消息对象时失败
     * 解决方法: 检查接收到的数据格式是否正确，protobuf 定义是否匹配
     */
    DECODE_FAILED: 200011
};
declare class WSocketClient {
    /** WSocketClient 版本 */
    static readonly VERSION = "1.4.7";
    /******************** 状态定义 ********************/
    /**
     * 初始状态
     */
    static readonly NONE = 0;
    /**
     * 断连状态
     */
    static readonly DISCONNECTED = 1;
    /**
     * 正在连接状态
     */
    static readonly CONNECTING = 2;
    /**
     * 连接成功状态
     */
    static readonly CONNECTTED = 3;
    /**
     * protobufjs 原始对象
     * 用于 protobuf 消息的序列化和反序列化
     */
    static protobuf: any;
    /**
     * 客户端配置对象
     */
    config: {
        /**
         * 调试模式
         * 是否开启调试模式，开启后会输出调试日志
         * @default false
         */
        debugMode: boolean;
        /**
         * WebSocket 类构造函数，默认使用浏览器自带的 WebSocket
         * 可以替换为自定义的 WebSocket 实现（如 Node.js 的 ws 库）
         */
        WebSocket: {
            new (url: string | URL, protocols?: string | string[]): WebSocket;
            prototype: WebSocket;
            readonly CONNECTING: 0;
            readonly OPEN: 1;
            readonly CLOSING: 2;
            readonly CLOSED: 3;
        };
        /**
         * 连接重试次数
         * 当连接失败时，最多重试的次数
         * @default 3
         */
        connectRetry: number;
        /**
         * 连接重连间隔（毫秒）
         * 每次重连之间的等待时间
         * @default 5000
         */
        connectInterval: number;
        /**
         * 连接超时时间（毫秒）
         * 从开始连接到连接成功或失败的最大等待时间
         * @default 10000
         */
        connectTimeout: number;
        /**
         * 协议超时时间（毫秒）
         * 发送请求后等待响应的最大时间，超过此时间将触发 onProtocolTimeout 回调
         * @default 10000
         */
        protocolTimeout: number;
        /**
         * 心跳超时时间（毫秒）
         * 心跳响应超时时间，超过此时间未收到心跳响应将断开连接
         * @default 15000
         */
        heartbeatTimeout: number;
        /**
         * 心跳间隔时间（毫秒）
         * 每隔多长时间发送一次心跳包
         * @default 5000
         */
        heartbeatInterval: number;
        /**
         * WS状态检测间隔时间（毫秒）
         * @default 500
         */
        tickInterval: number;
        /**
         * 自动断线重连，默认开启
         * 当连接意外断开时，是否自动尝试重新连接
         * @default true
         */
        autoReconnect: boolean;
        /**
         * 【Android】wss连接pem证书，CocosCreator3.5+以上不再需要此参数
         * 参考 https://forum.cocos.org/t/topic/151320/4
         */
        cacert: string;
        /**
         * 连接成功回调
         * @param type 连接成功类型
         *         - 1：正常连接成功
         *         - 2：断线重连成功
         */
        onConnected: (type: number) => void;
        /**
         * 连接断开回调
         * @param type 断开连接类型
         *         - 1：连接超时
         *         - 2：断线重连状态重连超时
         *         - 3：心跳超时
         *         - 10：断线重连状态错误或断开
         *         - 11：手动关闭
         *         - 12：onerror
         *         - 13：onclose
         * @param autoRetryConnect 是否会自动重试连接，true表示内部将自动去重连，false表示不会重连需要客户端弹窗提示
         * @param reason           断开连接原因说明
         */
        onDisconnect: (type: number, autoRetryConnect: boolean, reason: any) => void;
        /**
         * 【非必要】自动重连开始回调函数
         * 当开始自动重连时触发
         * 无参数
         */
        onAutoReconnectStart: (...args: any[]) => void;
        /**
         * 【非必要】协议超时回调函数（不会主动断开连接）,每个协议只可能触发一次心跳超时回调
         * @param request 超时的请求对象，包含以下属性：
         *   - seqId: 序列号（number）
         *   - time: 发送时间戳（number）
         *   - msgName: 消息名称（string）
         *   - timeout: 是否已超时（boolean）
         *   - callback: 原始回调函数
         */
        onProtocolTimeout: (...args: any[]) => void;
        /**
         * 【非必要】心跳回调函数
         * 每次发送心跳包后触发
         * @param response 心跳响应对象，包含 code（状态码）、data（响应数据）等字段
         */
        onHeartbeat: (...args: any[]) => void;
        /**
         * 【非必要】状态变化回调函数
         * @param state 新的连接状态（NONE、DISCONNECTED、CONNECTING、CONNECTTED）
         */
        onStateChange: (...args: any[]) => void;
    };
    /**
     * 获取 WSocketClient 单例实例
     * @returns WSocketClient 的单例实例
     */
    static getInstance(): WSocketClient;
    /**
     * Protobuf 辅助对象
     * 用于处理 protobuf 消息的编码和解码
     */
    protobufUtil: any;
    /**
     * 获取 WebSocket 实例
     * @returns 当前使用的 WebSocket 实例，如果未连接则返回 null
     */
    get wsocket(): any;
    /**
     * 获取当前连接的 WebSocket 地址
     * @returns 当前连接的 WebSocket URL，如果未连接则返回空字符串
     */
    get url(): string;
    /**
     * 获取是否已连接
     * @returns 如果当前状态为 CONNECTTED 则返回 true，否则返回 false
     */
    get isConnected(): boolean;
    /**
     * 获取是否正在重连
     * @returns 如果正在自动重连则返回 true，否则返回 false
     */
    get isReconnecting(): boolean;
    /**
     * 获取当前连接状态
     * @returns 当前连接状态值（NONE=0, DISCONNECTED=1, CONNECTING=2, CONNECTTED=3）
     */
    get state(): number;
    /**
     * 获取服务器与客户端的时间差（毫秒）
     * 通过心跳包计算得出，值为 serverTime - clientTime
     * @returns 时间差（毫秒），正数表示服务器时间比客户端快
     */
    get ping(): number;
    /**
     * 获取服务器当前时间（毫秒时间戳）
     * 基于客户端时间和时间差计算得出
     * @returns 服务器当前时间的毫秒时间戳
     */
    get serverTime(): number;
    /**
     * 重置所有状态和数据
     * 关闭连接、清空所有回调、停止定时器、重置所有内部状态
     * 调用后需要重新调用 setConfig 和 connect 才能使用
     */
    reset(): void;
    /**
     * 设置协议配置（proto.ts中配置的proto_config）
     * 必须在调用 connect 之前调用此方法
     * @param proto_config 协议配置对象
     * @param proto_config.protoName 协议名称，通常为 "proto.json"
     * @param proto_config.proto_define protobuf 定义对象，包含消息和枚举定义
     * @param proto_config.proto_configs 协议配置映射表，Map 类型，key 为 cmdMerge，value 为 [cmdMerge, request, response] 数组
     */
    setProtoConfig(proto_config: {
        protoName: string;
        proto_define: any;
        proto_configs: any;
    }): void;
    /**
     * 设置连接状态
     * 状态变化时会触发相应的回调函数和内部逻辑
     * @param val 新的状态值（NONE、DISCONNECTED、CONNECTING、CONNECTTED）
     */
    setState(val: number): void;
    /**
     * 连接 WebSocket 服务器
     * 请确保在调用此方法之前已经调用了 setConfig
     * @param serverURL WebSocket 服务器地址，格式如 "ws://localhost:8080" 或 "wss://example.com"
     * @param callback 连接结果回调函数
     * @param callback.success 连接是否成功
     * @param callback.client WSocketClient 实例
     */
    connect(serverURL: string, callback: (success: boolean, client: WSocketClient) => void): void;
    /**
     * 关闭 WebSocket 连接
     * @param code WebSocket 关闭代码，默认为 -1。标准关闭代码：1000=正常关闭，1001=端点离开，1006=异常关闭
     */
    close(): void;
    /**
     * 发送消息到服务器
     * 只有在连接成功（CONNECTTED 状态）时才能发送消息
     * @param msgName 消息名称，必须在 proto_config 中已配置
     * @param playload 消息负载对象，需要符合对应消息类型的 protobuf 定义
     * @param callback 响应回调函数，当收到服务器响应时调用
     * @param callback.msgName 请求的消息名称
     * @param callback.response 响应对象，包含 code（响应状态码）、data（响应数据）、msgName（响应消息名称）
     * @returns 如果发送成功，返回请求对象（包含 seqId、time、msgName、callback），否则返回 null
     */
    send(msgName: string, playload: object, callback: (msgName: string, response: any) => void): {
        seqId: number;
        time: number;
        msgName: string;
        /**
         * 是否已发送心跳超时
         */
        timeout: boolean;
        callback: (msgName: string, response: any) => void;
    };
    /**
     * 监听服务器推送消息（通知消息）
     * - 可以为同一个消息名称注册多个回调函数，按优先级排序执行
     * - 除了NTF推送，该接口可以监听服务器的任意消息数据，包括CS模式请求返回
     * @param msgName 消息名称，服务器推送的消息类型
     * @param callback 回调函数，当收到对应消息时调用
     * @param callback.msgName 消息名称
     * @param callback.response 响应对象，包含 code（响应状态码）、data（响应数据）、msgName（消息名称）
     * @param priority 优先级，默认 0，数值越大优先级越高，相同优先级的按注册顺序执行
     */
    onNTF(msgName: string, callback: (msgName: string, response: any) => void, priority?: number): void;
    /**
     * 取消监听协议返回消息（包括推送和普通CS模式）
     * @param msgName 消息名称，要取消监听的消息类型
     * @param callback 可选，要移除的特定回调函数。如果不传此参数，则删除该消息名称下的所有回调函数
     */
    offNTF(msgName: string, callback?: (msgName: string, playload: any) => void): void;
    /**
     * 处理接收到的数据
     * @param data 接收到的数据
     */
    /**
     * WS状态检测
     */
    /**
     * 停止ticker检测
     */
    /**
     * 发送心跳包
     */
}

// 导出 WSocketClient 类
export = WSocketClient;
export as namespace WSocketClient;
