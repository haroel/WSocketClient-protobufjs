/**
 * Auto-generated by build.js
 * Contains a simplified global declaration for WSocketClient.
 * All internal dependencies are replaced with 'any'.
 */

declare type WSocket = any;
declare type __global = any;
declare type WSocketProtoBuf = any;



/**
 * WebSocket 客户端错误码定义
 * 错误码范围说明：
 * - 100000-199999: 连接相关错误
 * - 200000-299999: 协议处理相关错误
 */
declare const WSMessage: {
    /******************** 连接相关错误 (100000-199999) ********************/
    
    /**
     * 请先调用 setConfig 方法
     * 错误码: 100000
     * 触发场景: 在调用 connect() 方法之前未调用 setConfig() 设置协议配置
     * 解决方法: 确保在连接前先调用 client.setConfig(proto_config)
     */
    CALL_SET_CONFIG_FIRST: 100000;

    /**
     * 当前正在连接 WebSocket，请勿重复连接
     * 错误码: 100001
     * 触发场景: 在连接状态为 CONNECTING 时，再次调用 connect() 方法
     * 解决方法: 等待当前连接完成后再尝试连接
     */
    CONNECTING_REPEAT_ERROR: 100001;

    /**
     * 连接超时
     * 错误码: 100002
     * 触发场景: 从开始连接到连接成功或失败的时间超过了 config.connectTimeout 设置的值
     * 解决方法: 检查网络连接，或增加 connectTimeout 的值
     */
    CONNECT_TIMEOUT: 100002;

    /**
     * 协议超时
     * 错误码: 100003
     * 触发场景: 发送请求后，在 config.protocolTimeout 时间内未收到服务器响应
     * 解决方法: 检查服务器是否正常响应，或增加 protocolTimeout 的值
     */
    PROTOCOL_TIMEOUT: 100003;

    /**
     * 心跳超时
     * 错误码: 100004
     * 触发场景: 发送心跳包后，在 config.heartbeatTimeout 时间内未收到心跳响应
     * 解决方法: 检查网络连接，服务器可能会主动断开连接
     */
    HEARTBEAT_TIMEOUT: 100004;

    /**
     * 心跳响应失败
     * 错误码: 100005
     * 触发场景: 收到心跳响应，但响应状态码不为 0（表示心跳失败）
     * 解决方法: 检查服务器心跳处理逻辑
     */
    HEARTBEAT_FAILED: 100005;

    /******************** 协议处理相关错误 (200000-299999) ********************/

    /**
     * Protobuf 解析错误
     * 错误码: 200000
     * 触发场景: 在 setConfig() 时，protobuf 定义文件解析失败，无法找到对应的 package
     * 解决方法: 检查 proto_define 配置是否正确，确保 package 名称匹配
     */
    PROTO_PARSE_ERROR: 200000;

    /**
     * CSV 配置错误，cmdMerge 无法找到对应的配置
     * 错误码: 200001
     * 触发场景: 收到服务器消息时，根据 cmdMerge 无法在 proto_configs 中找到对应的协议配置
     * 解决方法: 检查 ProtoConfig.csv 配置，确保 cmdMerge 值已正确配置
     */
    CSV_ERROR: 200001;

    /**
     * CSV 配置错误，响应消息名称为空
     * 错误码: 200002
     * 触发场景: 收到服务器消息时，协议配置中缺少响应消息名称（response 字段为空）
     * 解决方法: 检查 ProtoConfig.csv 配置，确保每个 cmdMerge 都配置了对应的 response 消息名称
     */
    CSV_NO_RESPONSE: 200002;

    /**
     * 找不到 cmdMerge 配置
     * 错误码: 200003
     * 触发场景: 发送消息时，根据消息名称（msgName）无法在 proto_configs 中找到对应的 cmdMerge
     * 解决方法: 检查 ProtoConfig.csv 配置，确保该消息名称已正确配置 cmdMerge
     */
    CMDMERGE_NOT_FOUND: 200003;

    /**
     * 找不到 ExternalMessage 定义
     * 错误码: 200004
     * 触发场景: 编码消息时，在 protobuf 定义中找不到 ExternalMessage 类型
     * 解决方法: 检查 .proto 文件，确保定义了 ExternalMessage 消息类型
     */
    EXTERNAL_MESSAGE_NOT_FOUND: 200004;

    /**
     * 编码消息失败
     * 错误码: 200005
     * 触发场景: 将消息对象编码为 Protobuf 二进制数据时失败
     * 解决方法: 检查消息对象格式是否正确，是否符合 protobuf 定义
     */
    ENCODE_MESSAGE_FAILED: 200005;

    /**
     * 解码消息失败
     * 错误码: 200006
     * 触发场景: 将 Protobuf 二进制数据解码为消息对象时失败
     * 解决方法: 检查接收到的数据格式是否正确，protobuf 定义是否匹配
     */
    DECODE_MESSAGE_FAILED: 200006;

    /**
     * Builder.build 返回 null
     * 错误码: 200007
     * 触发场景: 调用 protobuf Builder.build() 方法时返回 null，无法获取 package 对象
     * 解决方法: 检查 protobuf 定义是否正确加载，package 名称是否正确
     */
    BUILDER_BUILD_FAILED: 200007;
};
declare class WSocketClient {
    static readonly VERSION = "1.0";
    /******************** 状态定义 ********************/
    /**
     * 初始状态
     */
    static readonly NONE = 0;
    /**
     * 断连状态
     */
    static readonly DISCONNECTED = 1;
    /**
     * 正在连接状态
     */
    static readonly CONNECTING = 2;
    /**
     * 连接成功状态
     */
    static readonly CONNECTTED = 3;
    /**
     * protobufjs 对象
     * 用于 protobuf 消息的序列化和反序列化
     */
    static protobuf: any;
    /**
     * 客户端配置对象
     */
    config: {
        /**
         * WebSocket 类构造函数，默认使用浏览器自带的 WebSocket
         * 可以替换为自定义的 WebSocket 实现（如 Node.js 的 ws 库）
         */
        WebSocket: {
            new (url: string | URL, protocols?: string | string[]): WebSocket;
            prototype: WebSocket;
            readonly CONNECTING: 0;
            readonly OPEN: 1;
            readonly CLOSING: 2;
            readonly CLOSED: 3;
        };
        /**
         * 连接重试次数
         * 当连接失败时，最多重试的次数
         * @default 3
         */
        connectRetry: number;
        /**
         * 连接重连间隔（毫秒）
         * 每次重连之间的等待时间
         * @default 5000
         */
        connectInterval: number;
        /**
         * 连接超时时间（毫秒）
         * 从开始连接到连接成功或失败的最大等待时间
         * @default 10000
         */
        connectTimeout: number;
        /**
         * 协议超时时间（毫秒）
         * 发送请求后等待响应的最大时间，超过此时间将触发 onProtocolTimeout 回调
         * @default 10000
         */
        protocolTimeout: number;
        /**
         * 心跳超时时间（毫秒）
         * 心跳响应超时时间，超过此时间未收到心跳响应将断开连接
         * @default 15000
         */
        heartbeatTimeout: number;
        /**
         * 心跳间隔时间（毫秒）
         * 每隔多长时间发送一次心跳包
         * @default 5000
         */
        heartbeatInterval: number;
        /**
         * 自动断线重连，默认开启
         * 当连接意外断开时，是否自动尝试重新连接
         * @default true
         */
        autoReconnect: boolean;
        /**
         * 状态变化回调函数
         * @param state 新的连接状态（NONE、DISCONNECTED、CONNECTING、CONNECTTED）
         */
        onStateChange: (...args: any[]) => void;
        /**
         * 连接超时回调函数
         * 当连接超时时触发
         */
        onConnectTimeout: (...args: any[]) => void;
        /**
         * 自动重连开始回调函数
         * 当开始自动重连时触发
         */
        onAutoReconnectStart: (...args: any[]) => void;
        /**
         * 自动重连结束回调函数
         * @param success 重连是否成功
         */
        onAutoReconnectEnd: (...args: any[]) => void;
        /**
         * 协议超时回调函数
         * @param request 超时的请求对象，包含 seqId、time、msgName 等信息
         */
        onProtocolTimeout: (...args: any[]) => void;
        /**
         * 心跳超时回调函数
         * 当心跳响应超时时触发
         */
        onHeartbeatTimeout: (...args: any[]) => void;
        /**
         * 心跳回调函数
         * 每次发送心跳包后触发
         */
        onHeartbeat: (...args: any[]) => void;
        /**
         * WebSocket 连接打开回调函数
         * 当 WebSocket 连接成功建立时触发
         */
        onOpen: (...args: any[]) => void;
        /**
         * WebSocket 连接关闭回调函数
         * 当 WebSocket 连接关闭时触发
         */
        onClose: (...args: any[]) => void;
        /**
         * WebSocket 错误回调函数
         * 当 WebSocket 发生错误时触发
         */
        onError: (...args: any[]) => void;
        /**
         * 消息接收回调函数
         * 当收到服务器消息时触发（在消息分发到具体回调之前）
         * @param msg 解码后的外部消息对象
         */
        onMessage: (msg: any) => void;
    };
    /**
     * 获取 WSocketClient 单例实例
     * @returns WSocketClient 的单例实例
     */
    static getInstance(): WSocketClient;
    /**
     * Protobuf 辅助对象
     * 用于处理 protobuf 消息的编码和解码
     */
    protobufHelper: any;
    /**
     * 获取 WebSocket 实例
     * @returns 当前使用的 WebSocket 实例，如果未连接则返回 null
     */
    get wsocket(): any;
    /**
     * 获取当前连接的 WebSocket 地址
     * @returns 当前连接的 WebSocket URL，如果未连接则返回空字符串
     */
    get url(): string;
    /**
     * 获取是否已连接
     * @returns 如果当前状态为 CONNECTTED 则返回 true，否则返回 false
     */
    get isConnected(): boolean;
    /**
     * 获取是否正在重连
     * @returns 如果正在自动重连则返回 true，否则返回 false
     */
    get isReconnecting(): boolean;
    /**
     * 获取当前连接状态
     * @returns 当前连接状态值（NONE=0, DISCONNECTED=1, CONNECTING=2, CONNECTTED=3）
     */
    get state(): number;
    /**
     * 设置连接状态
     * 状态变化时会触发相应的回调函数和内部逻辑
     * @param val 新的状态值（NONE、DISCONNECTED、CONNECTING、CONNECTTED）
     */
    setState(val: number): void;
    /**
     * 获取服务器与客户端的时间差（毫秒）
     * 通过心跳包计算得出，值为 serverTime - clientTime
     * @returns 时间差（毫秒），正数表示服务器时间比客户端快
     */
    get ping(): number;
    /**
     * 获取服务器当前时间（毫秒时间戳）
     * 基于客户端时间和时间差计算得出
     * @returns 服务器当前时间的毫秒时间戳
     */
    get serverTime(): number;
    /**
     * 重置所有状态和数据
     * 关闭连接、清空所有回调、停止定时器、重置所有内部状态
     * 调用后需要重新调用 setConfig 和 connect 才能使用
     */
    reset(): void;
    /**
     * 设置协议配置（proto.ts中配置的proto_config）
     * 必须在调用 connect 之前调用此方法
     * @param proto_config 协议配置对象
     * @param proto_config.protoName 协议名称，通常为 "proto.json"
     * @param proto_config.package protobuf 包名
     * @param proto_config.proto_define protobuf 定义对象，包含消息和枚举定义
     * @param proto_config.proto_configs 协议配置映射表，Map 类型，key 为 cmdMerge，value 为 [cmdMerge, request, response] 数组
     */
    setConfig(proto_config: {
        protoName: string;
        package: string;
        proto_define: any;
        proto_configs: any;
    }): void;
    /**
     * 连接 WebSocket 服务器
     * 请确保在调用此方法之前已经调用了 setConfig
     * @param serverURL WebSocket 服务器地址，格式如 "ws://localhost:8080" 或 "wss://example.com"
     * @param callback 连接结果回调函数
     * @param callback.success 连接是否成功
     * @param callback.client WSocketClient 实例
     */
    connect(serverURL: string, callback: (success: boolean, client: WSocketClient) => void): void;
    /**
     * 关闭 WebSocket 连接
     * @param code WebSocket 关闭代码，默认为 -1。标准关闭代码：1000=正常关闭，1001=端点离开，1006=异常关闭
     */
    close(code?: number): void;
    /**
     * 发送消息到服务器
     * 只有在连接成功（CONNECTTED 状态）时才能发送消息
     * @param msgName 消息名称，必须在 proto_config 中已配置
     * @param playload 消息负载对象，需要符合对应消息类型的 protobuf 定义
     * @param callback 响应回调函数，当收到服务器响应时调用
     * @param callback.msgName 请求的消息名称
     * @param callback.response 响应对象，包含 code（响应状态码）、data（响应数据）、msgName（响应消息名称）
     * @returns 如果发送成功，返回请求对象（包含 seqId、time、msgName、callback），否则返回 null
     */
    send(msgName: string, playload: object, callback: (msgName: string, response: any) => void): {
        seqId: number;
        time: number;
        msgName: string;
        callback: (msgName: string, response: any) => void;
    };
    /**
     * 监听服务器推送消息（通知消息）
     * 可以为同一个消息名称注册多个回调函数，按优先级排序执行
     * @param msgName 消息名称，服务器推送的消息类型
     * @param callback 回调函数，当收到对应消息时调用
     * @param callback.msgName 消息名称
     * @param callback.response 响应对象，包含 code（响应状态码）、data（响应数据）、msgName（消息名称）
     * @param priority 优先级，默认 0，数值越大优先级越高，相同优先级的按注册顺序执行
     */
    onNTF(msgName: string, callback: (msgName: string, response: any) => void, priority?: number): void;
    /**
     * 取消监听协议返回消息（包括推送和普通CS模式）
     * @param msgName 消息名称，要取消监听的消息类型
     * @param callback 可选，要移除的特定回调函数。如果不传此参数，则删除该消息名称下的所有回调函数
     */
    offNTF(msgName: string, callback?: (msgName: string, playload: any) => void): void;
}
